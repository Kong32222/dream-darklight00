#include "xheaacsuperframe.h"
#include "../util/CRC.h"

XHEAACSuperFrame::XHEAACSuperFrame():
    AudioSuperFrame (),numChannels(0),
    superFrameSize(0),payload(),frameSize(),borders()
{    
}

void
XHEAACSuperFrame::init(const CAudioParam& audioParam, unsigned frameSize)
{
    numChannels = audioParam.AM_MONO?1:2;
    superFrameSize = frameSize;
    payload.resize(0);
    borders.resize(0);
}

unsigned XHEAACSuperFrame::getSuperFrameDurationMilliseconds()
{
    return 0; // TODO is this variable or fixed?
}
/*
     * 5.3.1.3 Transport of xHE-AAC audio frames within the payload section
    The USAC access unit encoder generates a continuous sequence of audio frames at a constant bit rate over the long term.
    The individual length of each audio frame in the continuous sequence is variable but constrained by the bit
    reservoir mechanism in the audio encoder to allow for improved audio quality. The encoder's bit reservoir buffer level is
    signalled to the decoder, to reduce required input buffer size and the extra tune-in delay to a minimum.

    Audio frame transport

    The xHE-AAC audio encoder generates a sequence of audio super frames (occupying one DRM logical frame for robustness modes A, B, C and D,
    or two DRM logical frames for robustness mode E). The audio frames as generated by the USAC access unit encoder are inserted into
    the Payload section of the audio super frame as a continuous byte sequence without any padding bytes in-between.
    Should padding be required to achieve the overall fixed bit rate and byte-alignment, it is inserted by the USAC access unit encoder
    into the audio frames themselves.

    The frame borders of audio frames do not need to be and typically will not be aligned with the audio super frame boundaries.
    Instead, audio frames are not synchronized to audio super frames; they continue from the current audio super frame into the Payload
    section of subsequent audio super frame(s). The frame borders within the Payload section of an audio super frame can be derived from
    the Header and Directory section of the audio super frame (there may be none!).

    An audio super frame shall not contaixn a Frame border description element without at least one byte of the corresponding audio frame data.
    If the available space in an audio super frame is not sufficient to hold at least 1 byte of the next audio frame in the Payload section
    plus the 2 bytes of the related extra Frame border description element in the Directory section, then the remaining space in the Payload
    section shall be filled with audio frame content, while the related Frame border description element is carried as the first Frame border
    description element in the Directory section of the following audio super frame (i.e. located at the end of the Directory section).
    The Frame border index value of such a delayed Frame border description element shall carry the special value 0xFFE or 0xFFF; with 0xFFF
    indicating the start of the audio frame at the last byte of the Payload section of the previous audio super frame. A decoder therefore
    always needs to buffer the last 2 bytes within the Payload section for a possible later processing along with the next audio super frame.
     */
/*
    * The xHE-AAC audio super frame Header section has the following structure:
    • Frame border count
    • Bit reservoir level
    • Fixed header CRC
    The following definitions apply:
    4 bits. 4 bits. 8 bits
    * */
bool XHEAACSuperFrame::parse(CVectorEx<_BINARY>& asf)
{
    bool ok = true;
    /*
     *  Frame border count :  4 bits. 表示帧边界计数 确定当前帧的边界或者帧之间的关系。
     * 功能: 在音频解码中，帧边界计数可以用于 管理和同步 帧，确保解码器能够正确地处理连续的音频帧
     *
     *  Bit reservoir level:  4 bits.  比特储存器的级别
     * 通过管理比特储存器的级别，可以在保持总体比特率不变的情况下，提高某些帧的音频质量。
     * 这对于处理瞬时高复杂度的音频内容特别有用。

     *  Fixed header CRC   :  8 bits.
    */
    /*
        帧边界计数: 6 ,比特储存器的级别: 13
        帧边界计数: 6 ,比特储存器的级别: 13
        帧边界计数: 6 ,比特储存器的级别: 13
        帧边界计数: 7 ,比特储存器的级别: 13
*/
    unsigned frameBorderCount = asf.Separate(4);    // 6 6 6 7
    unsigned bitReservoirLevel = asf.Separate(4);   // 13
//    std::cout<<"帧边界计数: "<<frameBorderCount<<
//               " ,比特储存器的级别: "<<bitReservoirLevel<<std::endl;
    CCRC CRCObject;
    CRCObject.Reset(8);
    CRCObject.AddByte((frameBorderCount << 4) | bitReservoirLevel);

    if(CRCObject.CheckCRC(asf.Separate(8))) {
        //cerr << endl << "superframe crc ok" << endl;
    }
    else {
        //超帧CRC坏，但希望 frameBorderCount 是正确的
        //cerr << endl << "superframe crc bad but will hope the frameBorderCount is OK" << endl;
    }
    // TODO handle reservoir
    // 计算音频数据的比特储存器级别，并确定目录部分的偏移量这里，
    // 通过将比特储存器级别加1，乘以384（每个通道的比特率），再乘以通道数量，计算出总的比特储存器容量
    unsigned bitResLevel = (bitReservoirLevel+1) * 384 * numChannels;
    //目录部分在有效负载中的位置，即从超帧大小减去两倍的帧边界计数。
    unsigned directory_offset = superFrameSize - 2*frameBorderCount;
    //有效负载的当前大小，通常用于后续数据的写入或处理
    size_t start = payload.size();
    /*
        57 bytes left from previous superframe
    payload start 57 bit reservoir level
    13 bitResLevel
    10752 superframe size 734
    directory offset 5776
    bits 722 bytes

     52 bytes left from previous superframe(前一个超帧剩下的字节数)
    payload start :52 ,
    bit reservoir level(bit 储层程度) 13 ,
    bitResLevel 10752 ,
    superframe size :669 ,
    directory offset: 5256 ,
    bits:657 bytes

 */
//    cerr << start << " bytes left from previous superframe(前一个超帧剩下的字节数)" << endl;
//    cerr << "payload start :" << start
//         << " , bit reservoir level(bit 储层程度) "<< bitReservoirLevel
//         << " , bitResLevel "<< bitResLevel
//         << " , superframe size :" << superFrameSize
//         << " , directory offset: " << 8*directory_offset
//         << " , bits:" << directory_offset << " bytes" << endl;

    // get the payload
    // 提取有效负载数据，直到达到目录偏移量
    for (size_t i=2; i < directory_offset; i++) {
        if (asf.Size() == 0) {
            printf("DRM xHE-AAC asf UNDERRUN 1\n");
            return false;
        }
        payload.push_back(asf.Separate(8));
    }
    borders.resize(frameBorderCount);
    frameSize.resize(frameBorderCount);


    //printf("xHE sfs=%d start=%zu diroff=%d fbc=%d ", superFrameSize, start, directory_offset, frameBorderCount);
    if (frameBorderCount > 0)
    {
        // get the directory 正在提取目录数据  目录包含 格式
        for (int i = int(frameBorderCount-1); i >= 0; i--)
        {
            if (asf.Size() == 0) {
                printf("DRM xHE-AAC asf UNDERRUN 2\n");
                return false;
            }
            //帧边框索引（12 位）：指示相应音频帧的第一个字节在有效负载部分中的索引位置。
            unsigned frameBorderIndex = asf.Separate(12);
            //帧边框计数（4 位）：包含在头部部分中携带的帧边框计数值。
            unsigned frameBorderCountRepeat = asf.Separate(4);
            if (frameBorderCountRepeat != frameBorderCount) {
                ok = false;
            }
            //cerr << "border " << i << " of " << frameBorderCountRepeat << "/" << frameBorderCount << " starts at " << hex << frameBorderIndex << dec << endl;
            borders[unsigned(i)] = frameBorderIndex;
            //printf("%d:%d ", i, frameBorderIndex);
        }
        //printf("\n");
        if (!ok) {
            //printf("xHE-FBC-repeat-BAD! ");
            return false;
        }

        // set the borders relative to the start including the payload bytes from previous superframes
        switch (borders[0]) {

        case 0xffe: // delayed from previous superframe
            //cerr << "first frame has two bytes in previous superframe" << endl;
            if (start < 2) {
                //printf("xHE-0xffe! ");
                return false;
            }
            borders[0] = start-2;
            frameSize[0] = borders[0];
            break;

        case 0xfff: // the start of the audio frame at the last byte of the Payload section of the previous audio super frame
            //cerr << "first frame has one byte in previous superframe" << endl;
            if (start < 1) {
                //printf("xHE-0xfff! ");
                return false;
            }
            borders[0] = start-1;
            frameSize[0] = borders[0];
            break;

        default: // boundary in this superframe
            borders[0] += start;
#if 0
            if (borders[0] < 2) return false;
            borders[0] -= 2; // header not in payload
#endif
            frameSize[0] = borders[0];
            //cerr << "border 0 is " << borders[0] << " bytes from start of payload" << endl;
            break;
        }

        for (unsigned i=1; i < borders.size(); i++) {
            borders[i] += start;
#if 0
            borders[i] -= 2; // header not in payload
            unsigned bytes = borders[i] - borders[i-1];
#else
            unsigned bytes = borders[i] - borders[i-1];
#endif
            frameSize[i] = bytes;
            //cerr << "border " << i << " is " << borders[i] << " bytes from start of payload" << endl;
        }

#if 0
        printf("xHE i:fb:fsize ");
        for (unsigned i=0; i < borders.size(); i++) {
            printf("%d:%d:%d ", i, borders[i], frameSize[i]);
        }
#endif
    }
    else
    {
        // frameBorderCount == 0: spans entire ASF payload or bad data in header
        //printf("xHE-fullspan\n");
        audioFrame.resize(0);
        return ok;
    }

    // 以帧为单位计算时间  计算帧中的总字节数，并确定下一个帧剩余的字节数
    size_t bytesInFrames = 0;
    for (size_t i=0; i < frameSize.size(); i++) bytesInFrames += frameSize[i];
    size_t next = payload.size() - bytesInFrames;
    (void)next;
    //cerr << "payload is " << payload.size() << " bytes of which " << bytesInFrames << " are for this superframe and " << next << " are for the next superframe" << endl;

    //printf("xHE payload=%zu bytesInFrames=%zu next=%zu\n", payload.size(), bytesInFrames, next);

    // now copy into the audioFrames for simplicity 为了简单起见，现在复制到音频frame中
    // 将数据转换为音频帧
    size_t i=0;
    audioFrame.resize(frameBorderCount);
    audioFrame[i].resize(0);

    while (true) {
#if 0
        if (i >= audioFrame.size()) {
            printf("audioFrame size: i=%d af_size=%d frameBorderCount=%d\n", (int) i, (int) audioFrame.size(), frameBorderCount);
            exit(-1);
        }
        int psize = payload.size();
        if (psize == 0) {
            printf("payload size: i=%d af_size=%d af_size[i]=%d frameSize=%d frameBorderCount=%d\n",
                   (int) i, (int) audioFrame.size(), audioFrame[i].size(), frameSize[i], frameBorderCount);
            //exit(-1);
        }
#endif

        if (payload.empty())
        {
            //是缓冲区或者数据流中的不足。 "欠流" 或者 "欠冲"
            printf("DRM xHE-AAC payload UNDERRUN 缓冲区或者数据流中的不足 \n");
            return false;
        }
        audioFrame[i].push_back(payload.front());
        payload.pop_front();
        if (audioFrame[i].size() == frameSize[i]) {
            i++;
            if (i >= audioFrame.size()) break;
            audioFrame[i].resize(0);
        }
    }

    //cerr << "remaining payload is " << payload.size() << " bytes" << endl;
    //size_t allocated = 2 + 2*frameBorderCount; // bytes of the superframe for the header and directory
    //allocated += bytesInFrames - start; // do count bytes in frames but not the ones from previous superframes
    //allocated += next; // do count bytes for next superframe
    //cerr << "allocated " << allocated << " bytes out of " << superFrameSize << " in the superframe" << endl;

    return ok;

}

void XHEAACSuperFrame::getFrame(std::vector<uint8_t>& frame,
                                uint8_t& crc,
                                unsigned i)
{
    (void )crc;
    frame = audioFrame[i];
}
